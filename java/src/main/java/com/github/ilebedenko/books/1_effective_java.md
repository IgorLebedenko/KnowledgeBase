## Джошуа Блох - Java. Эффективное программирование

### 1. Создание и уничтожение объектов

#### 1.1 Рассмотрите применение статичных фабричных методов вместо конструкторов

<u>Преимущества:</u>

- имеют имена

Когда классу требуется несколько конструкторов с одинаковой сигнатурой,
замените конструкторы статическими фабричными методами с тщательно подобранными именами, чтобы подчеркнуть их различия.

Пример: `Biginteger(int, int, Random)` -> `BigInteger.probablePrime(int, Random)`

- не обязаны создавать новые объекты при каждом вызове

Это позволяет неизменяемым классам использовать предварительно сконструированные экземпляры или кешировать
экземпляры при их создании, чтобы избежать создания ненужных дубликатов объектов. 

Пример: `Boolean.valueOf(boolean)`

- могут возвращать объект любого подтипа их возвращаемого типа
  
API может возвращать объекты, не делая их классы открытыми. 
Сокрытие классов реализации таким способом приводит к очень компактному API.

- класс возвращенного объекта может варьироваться от вызова к вызову в зависимости от входных параметров

Клиенты не знают и не должны беспокоиться о классе объекта, который они получают от фабрики; 
для них важно только, что это некоторый подкласс ожидаемого типа.

Пример: `EnumSet` -> `RegularEnumSet`, `JumboEnumSet`

- класс возвращаемого объекта не обязан существовать во время разработки класса, содержащего метод

Пример: `JDBC`

<u>Недостатки:</u>

- классы без открытых или защищенных конструкторов не могут порождать подклассы

- трудно отличить от других статических методов

<u>Удачные имена:</u>

- from -> `Date.from(instant);`
- of -> `LocalDate.of(year, month, day);`
- valueOf -> `BigInteger.valueOf((Integer.MAX_VALUE);`
- instance\getInstance -> `StackWalker.getInstance(options);`
- create\newInstance -> `Array.newInstance(classObject, arrayLen);`
- getType -> `Files.getFileStore(path);`
- newType -> `Files.newBufferedReader(path);`
- type -> `Collections.list(legacyLitany);`


#### 1.2 При большом количестве параметров конструктора подумайте о проектном шаблоне Строитель

Статические фабрики и конструкторы имеют общее ограничение: 
они не масштабируются для большого количества необязательных параметров.

```java
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;

    public static class Builder {
        // Обязательные параметры
        private final int servingSize;
        private final int servings;
        // Необязательные параметры — инициализированы
        // значениями по умолчанию
        private int calories = 0;
        private int fat = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        this.servingSize = builder.servingSize;
        this.servings = builder.servings;
        this.calories = builder.calories;
        this.fat = builder.fat;
    }
}
```

```java
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
                                .calories(100)
                                .fat(35)
                                .build();
```

#### 1.3 Получайте синглтон с помощью закрытого конструктора или типа перечисления

Синглтон — это просто класс, который инстанцируется только один раз. 
Синглтоны обычно представляют собой либо объект без состояния, такой как функция, 
либо системный компонент, который уникален по своей природе.

Синглтон с полем public final:
```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {
    }
}
```

Синглтон со статической фабрикой:
```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() {
    }
    public static Elvis getInstance() {
        return INSTANCE;
    }
}
```

Чтобы сделать класс синглтона, который использует один из этих подходов, сериализуемым,
недостаточно просто добавить в его объявление implements `Serializable`. 
Для гарантии сохранения свойства синглтона объявите все поля экземпляра как `transient` и предоставьте метод `readResolve`. 
В противном случае при каждой десериализации сериализованного экземпляра будет создаваться новый экземпляр, 
что приведет к появлению ложных объектов.

```java
private Object readResolve() {
    return INSTANCE;
}
```

#### 1.4 Обеспечивайте неинстанцируемость с помощью закрытого конструктора

Иногда требуется написать класс, который представляет собой просто сгруппированные статические методы и статические поля.
Такие служебные классы не предназначены для создания экземпляров: их экземпляры не имеют смысла.

Класс можно сделать неинстанцируемым, добавляя в него закрытый конструктор.

```java
public class UtilityClass {
    private UtilityClass() {
        throw new IllegalStateException("Utility class");
    }
}
```

#### 1.5 Предпочитайте внедрение зависимостей жестко прошитым ресурсам

Не используйте синглтон или статический служебный класс для реализации класса, 
который зависит от одного или нескольких базовых ресурсов. 
Также не давайте классу непосредственно самому создавать эти ресурсы.

Вместо этого передавайте ресурсы, или фабрики для их создания, конструктору. 
Эта практика, известная как внедрение зависимостей, значительно повышает гибкость, степень повторного использования и 
возможности тестирования класса.

```java
public class SpellChecker {
    private final Lexicon dictionary;
    
    public SpellChecker(Lexicon dictionary) {
        this.dictionary = dictionary;
    }
}
```

```java
SpellChecker britishEnglishChecker = new SpellChecker(new BritishEnglishLexicon());
SpellCheker americanEnglishChecker = new SpellChecker(new AmericanEnglishLexicon());
```

#### 1.6 Избегайте создания излишних объектов

Зачастую целесообразно повторно использовать один объект вместо создания нового, 
функционально эквивалентного объекта всякий раз, когда он становится необходимым. 
Повторное использование может быть как более быстрым, так и более элегантным.

Создание одних объектов оказывается гораздо более дорогим, чем других.
Если вам многократно требуется такой “дорогой объект”, возможно, целесообразно кешировать его для повторного использования.

Одним из путей создания ненужных объектов является автоматическая упаковка (autoboxing). 
Автоматическая упаковка размывает, но не стирает различие между примитивными и упакованными примитивными типами.
Предпочитайте примитивы упакованным примитивам и следите за непреднамеренной автоматической упаковкой.

#### 1.7 Избегайте устаревших ссылок на объекты

Утечки памяти в языках со сборкой мусора очень коварны. 
Если ссылка на объект случайно сохранена, сборщик мусора не может удалить не только этот объект, но и все объекты, 
на которые он ссылается, и далее по цепочке.

Решение проблем такого рода очень простое: как только ссылки устаревают, их нужно обнулять.

Еще одним распространенным источником утечек памяти являются кеши. 
Поместив в кеш ссылку на некий объект, можно легко забыть о том, что она там есть, 
и хранить ссылку в кеше еще долгое время после того, как она стала ненужной.

Третий распространенный источник утечки памяти — приложения в режиме ожидания и другие обратные вызовы. 
Если вы реализуете API, в котором клиенты регистрируют обратные вызовы, но позже не отменяют эту регистрацию, 
то, если вы ничего не предпринимаете, они накапливаются.

#### 1.8 Избегайте финализаторов и очистителей

- с помощью финализатора или очистителя нельзя выполнять никакие операции, критичные по времени
- никогда не ставьте обновление сохраняемого (persistent) состояния в зависимость от финализатора или очистителя
- есть серьезные проблемы производительности при использовании финализаторов или очистителей
- финализаторы являются серьезной проблемой безопасности: они открывают ваш класс для атак финализаторов

#### 1.9 Предпочитайте try-with-resources использованию try-finally

Всегда предпочитайте try-с-ресурсами применению try-finally при работе с ресурсами, которые должны быть закрыты. 
Результирующий код получается короче и понятнее, а исключения, которые он генерирует, — более полезными.

```java
static void copy(String src, String dst) throws IOException {
    try (InputStream in = new FileInputStream(src);
         OutputStream out = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUFFER_SIZE];
        int n;
        while ((n = in.read(buf)) >= 0)
            out.write(buf, 0, n);
    }
}
```
